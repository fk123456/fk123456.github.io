<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Idea工具开发 SpringBoot整合JSP（毕设亲测可用）</title>
    <url>/2021/02/24/Idea%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-SpringBoot%E6%95%B4%E5%90%88JSP%EF%BC%88%E6%AF%95%E8%AE%BE%E4%BA%B2%E6%B5%8B%E5%8F%AF%E7%94%A8%EF%BC%89/</url>
    <content><![CDATA[<ol>
<li><p>因为，临近毕业了，自己虽然也学了很多框架。但是，都是在别人搭建好的基础上进行项目开发。但是springboot的官方文档上明确指出不提倡使用jsp进行前端开发，但是在校期间只学了jsp作为前端页面。所以，废话不多说，先上项目结构图。</p>
<p><img src="https://images2018.cnblogs.com/blog/1265109/201807/1265109-20180711204121401-447221111.jpg" alt="11"></p>
</li>
</ol>
]]></content>
      <tags>
        <tag>框架搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程核心编程一</title>
    <url>/2021/02/23/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E4%B8%80/</url>
    <content><![CDATA[<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><ol>
<li>进程<ol>
<li>举例来说，就说windows任务管理器里面的一个个exe程序。</li>
<li>术语来说，操作系统结构的基础，是一个程序执行的过程，它是系统进行资源分配和调度的一个独立单元。</li>
</ol>
</li>
<li>线程<ol>
<li>举例来说，QQ.exe是一个进行，里面运行的视频线程、下载文件线程、数据传输线程等。</li>
<li>术语来说：进程中独立运行的子任务。</li>
</ol>
</li>
<li>为什么要使用多线程<ol>
<li>单线程环境：任务1用时10秒，任务2用时1秒，则总耗时为11秒。</li>
<li>多线程环境：CPU在任务1和任务2之间来回切换，任务2不必等10秒再运行，系统效率得到提升。</li>
</ol>
</li>
</ol>
<h2 id="使用多线程"><a href="#使用多线程" class="headerlink" title="使用多线程"></a>使用多线程</h2><ol>
<li>下面显示的是一个叫作main线程在执行main()方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName()); &lt;!-- main --&gt;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<ol>
<li><p>继承Thread类</p>
<ol start="2">
<li>可以发现run方法执行的时间比较晚，这也说明了代码运行结果与代码执行顺序或调用顺序是无关的。</li>
<li>调用了线程的start()方法，而不是run()方法。此过程就是通知线程规划器，等待调研线程对象的run()方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hahaha&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start(); &lt;!-- hahaha --&gt;</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 运行结束! --&gt;</span><br><span class="line">&lt;!-- hahaha --&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现Runnable接口</p>
<ol>
<li><p>我们可以发现Runnable接口，没有start()方法，所以我们把Runnable对象放到Thread类去执行。其实Thread类的构造方法支持传入一个Runnable接口，而Thread类实现了Runnable接口，所以可以这样执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hahaha&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">        thread.start(); &lt;!-- hahaha --&gt;</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!-- 运行结束! --&gt;</span><br><span class="line">&lt;!-- hahaha --&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Thread</span>(<span class="title">Runnable</span> <span class="title">target</span>) </span>&#123;</span><br><span class="line">  init(<span class="keyword">null</span>, target, <span class="string">&quot;Thread- &quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="Thread-currentThread-getName-和This-getName"><a href="#Thread-currentThread-getName-和This-getName" class="headerlink" title="Thread.currentThread().getName()和This.getName()"></a>Thread.currentThread().getName()和This.getName()</h2><ol>
<li><p>举例1:</p>
<ol>
<li><p>currentThread()方法：返回代码段正在被哪个线程调用的信息</p>
</li>
<li><p>构造方法被Thread调用，run方法被Thread调用</p>
</li>
<li><p>Debug可以发现，new MyThread()时，该类的构造方法就执行了，所以分别为main和Thread-0，真正执行到start()方法时，run()方法被CPU调度到分别打印为Thread-1和Thread-0，这是因为Thread类的构造方法默认拼接”Thread-“ 加一个数字，从0开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()); &lt;!-- Thread-<span class="number">1</span> --&gt;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName()); &lt;!-- Thread-<span class="number">0</span> --&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()); &lt;!-- main --&gt;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName()); &lt;!-- Thread-<span class="number">0</span> --&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread(); &lt;!-- 此处执行构造方法Thread-<span class="number">0</span> --&gt;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myThread); &lt;!-- Thread-<span class="number">1</span> --&gt;</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>举例2:</p>
<ol>
<li><p>构造方法被main方法调用，run方法被MyThread调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()); &lt;!-- Thread-<span class="number">0</span> --&gt;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName()); &lt;!-- Thread-<span class="number">0</span> --&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()); &lt;!-- main --&gt;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName()); &lt;!-- Thread-<span class="number">0</span> --&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread(); &lt;!-- Thread-<span class="number">0</span> --&gt;</span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>举例 3：设置name</p>
<ol>
<li><p>构造方法还是一样的结果</p>
</li>
<li><p>分别给MyThread和Thread设置名字，run方法被Thread类调用，所以打印为Thread</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()); &lt;!-- Thread --&gt;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName()); &lt;!-- MyThread --&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()); &lt;!-- main --&gt;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName()); &lt;!-- Thread-<span class="number">0</span> --&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread(); &lt;!-- 此处执行构造方法Thread-<span class="number">0</span> --&gt;</span><br><span class="line">        myThread.setName(<span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myThread); &lt;!-- Thread-<span class="number">1</span> --&gt;</span><br><span class="line">        thread.setName(<span class="string">&quot;Thread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>举例4:</p>
<ol>
<li><p>构造方法还是一样的结果</p>
</li>
<li><p>run方法被MyThread调用，而且设置了name，所以都为MyThread</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()); &lt;!-- MyThread --&gt;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName()); &lt;!-- MyThread --&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()); &lt;!-- main --&gt;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName()); &lt;!-- Thread-<span class="number">0</span> --&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread(); &lt;!-- 此处执行构造方法Thread-<span class="number">0</span> --&gt;</span><br><span class="line">        myThread.setName(<span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line">        myThread.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行结束!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="实例变量与线程安全"><a href="#实例变量与线程安全" class="headerlink" title="实例变量与线程安全"></a>实例变量与线程安全</h2><ol>
<li><p>线程类中的实例变量针对其他线程可以有共享与不共享之分，这是判断线程安全与否的重要标志。</p>
</li>
<li><p>不共享实例变量</p>
<ol>
<li><p>因为分别创建了三个MyThread对象，而且他们各自调用自己内部的count互不干涉</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(<span class="string">&quot;由&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;计算 count= &quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread a = <span class="keyword">new</span> MyThread(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        MyThread b = <span class="keyword">new</span> MyThread(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        MyThread c = <span class="keyword">new</span> MyThread(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        a.start(); &lt;!-- <span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span> --&gt;</span><br><span class="line">        b.start(); &lt;!-- <span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span> --&gt;</span><br><span class="line">        c.start(); &lt;!-- <span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span> --&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>共享实例变量</p>
<ol>
<li><p>多个线程访问同一个变量，就可能造成线程安全问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(<span class="string">&quot;由&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;计算 count= &quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(myThread, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(myThread, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        Thread c = <span class="keyword">new</span> Thread(myThread, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">        &lt;!-- 由B计算 count= <span class="number">2</span> --&gt;</span><br><span class="line">        &lt;!-- 由B计算 count= <span class="number">1</span> --&gt;</span><br><span class="line">        &lt;!-- 由C计算 count= <span class="number">2</span> --&gt;</span><br><span class="line">        &lt;!-- 由A计算 count= <span class="number">2</span> --&gt;</span><br><span class="line">        &lt;!-- 由B计算 count= <span class="number">0</span> --&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述代码可以看到线程的另一个构造方法，接受一个Runnable接口，和name。该name就为线程的名称等效与setName()</p>
</li>
</ol>
</li>
<li><p>共享实例变量（线程安全做法）</p>
<ol>
<li><p>在 run方法前加入synchronized关键字，使多个线程在执行run方法时，排队进行处理。</p>
</li>
<li><p>当某个线程调用run方法前，先判断当前方法有没有被上锁，如果没有被锁上则进入该代码，否则不断的尝试去拿这把锁，直到拿到为止。</p>
</li>
<li><p>synchronized可以在任意对象及方法上加锁，而加锁的这段代码称为”互斥区”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此处不要使用循环</span></span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(<span class="string">&quot;由&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;计算 count= &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(myThread, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        Thread b = <span class="keyword">new</span> Thread(myThread, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        Thread c = <span class="keyword">new</span> Thread(myThread, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        b.start();</span><br><span class="line">        c.start();</span><br><span class="line">        &lt;!-- 由A计算 count= <span class="number">4</span> --&gt;</span><br><span class="line">        &lt;!-- 由C计算 count= <span class="number">3</span> --&gt;</span><br><span class="line">        &lt;!-- 由B计算 count= <span class="number">2</span> --&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="Thread类部分API解释"><a href="#Thread类部分API解释" class="headerlink" title="Thread类部分API解释"></a>Thread类部分API解释</h2><ol>
<li><p>isAlive()</p>
<ol>
<li>判断当前线程是否处于活动状态</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;run = &quot;</span> + <span class="keyword">this</span>.isAlive()); &lt;!-- <span class="keyword">true</span> --&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        System.out.println(myThread.isAlive()); &lt;!-- <span class="keyword">false</span> --&gt;</span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); &lt;!-- 模拟网络延迟 --&gt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(myThread.isAlive()); &lt;!-- <span class="keyword">false</span> --&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sleep()</p>
<ol>
<li>在指定的毫秒数内让当前”正在执行的线程”休眠。</li>
</ol>
</li>
<li><p>getId()</p>
<ol>
<li>取得线程的唯一标识</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        System.out.println(myThread.getId()); &lt;!-- <span class="number">9</span> --&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>yeild()</p>
<ol>
<li>放弃当前的CPU资源，将它让给其他的任务去占用CPU执行，但是放弃的时间不确定，可能刚刚放弃，马上又获得CPU时间片。</li>
<li>下面的代码分别为不执行yiled方法和执行yield方法，可以看到耗时明显不同</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">            count += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费时间 = &quot;</span> + (end - begin)); &lt;!-- <span class="number">9</span> --&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">            count += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费时间 = &quot;</span> + (end - begin)); &lt;!-- <span class="number">18</span> --&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><ol>
<li><p>interrupt()方法：</p>
<ol>
<li>该方法并不像for+break语句那样，马上就停止循环，而是在当前线程中打一个停止的标记，并不是真正的停止线程。</li>
</ol>
</li>
<li><p>判断线程是否是停止状态</p>
<ol>
<li>interrupted(); 测试当前线程是否已经中断<ol>
<li>该方法具有清除状态的功能，如果连续调用两次则返回为false</li>
</ol>
</li>
<li>isInterrupted(); 测试现场是否已经中断</li>
</ol>
</li>
<li><p>异常法停止线程</p>
<ol>
<li>可以看到，interrupt() 方法被执行到之后，run方法的interrupted()检测到被打断了，则抛出异常，for循环后面的代码不会继续执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(interrupted()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;我已经被停止了！我要退出了！&quot;</span>);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在for下面&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;进入到run方法的catch中了&quot;</span> + e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">            myThread.start();</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            myThread.interrupt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main catch&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i &#x3D; 39060</span><br><span class="line">i &#x3D; 39061</span><br><span class="line">i &#x3D; 39062</span><br><span class="line">end!</span><br><span class="line">我已经被停止了！我要退出了！</span><br><span class="line">进入到run方法的catch中了java.lang.InterruptedException</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">	at com.cmos.web.controller.MyThread.run(MyThread.java:18)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="废弃的方法"><a href="#废弃的方法" class="headerlink" title="废弃的方法"></a>废弃的方法</h2><ol>
<li>stop()、resume()、suspend()：这些方法不建议使用<ol>
<li>因为如果强制让线程停止则有可能使一些请理性的工作得不到完成</li>
<li>对锁定的对象进行解锁，导致数据得不到同步的处理，出现数据不一致的问题</li>
</ol>
</li>
</ol>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><ol>
<li>线程的优先级越高则获得到的CPU资源越多，但是不一定高优先级的进程一定能获得更多的CPU资源。</li>
<li>优先级分为1～10，默认为5</li>
<li>setPriority()方法设置线程的优先级</li>
<li>继承性<ol>
<li>比如A线程启动B线程，则B线程的优先级与A线程是一样的。</li>
</ol>
</li>
</ol>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><ol>
<li>Java线程分为两种，一种是用户线程，一种是守护线程。</li>
<li>当进程中不存在用户线程，则守护线程也会自动销毁。</li>
</ol>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>java并发</tag>
      </tags>
  </entry>
</search>
